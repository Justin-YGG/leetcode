======================
排序算法总结
======================

- **原地排序（Sorted in place）算法**：特指空间复杂度是 O(1) 的排序算法
- **稳定性**：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

**基于比较的算法**
-------------------------------


``冒泡排序（Bubble Sort）``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。
如果不满足就让它俩互换。``一次冒泡会让至少一个元素移动到它应该在的位置`` ，重复 n 次，就完成了 n 个数据的排序工作;

``如同水中气泡向上升``

.. image:: ../_static/images/bubble_sort.jpg

``当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作，增加一个 flag 标志位来判断``

.. note::

    - 是 ``稳定的算法``，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法
    - 是 ``原地算法``，无需额外的空间，空间复杂度为：O(1)

    - 最坏情况时间复杂度：O(n^2)，数组逆序，需要 ``n 次冒泡``
    - 最好情况时间复杂度：O(n)，数组为有序，只需 ``一次冒泡``
    - 平均时间复杂度：O(n^2)

.. code:: python

    def bubble_sort(array):
        length = len(array)
        if length <= 1:
            return array
        for i in range(1, length):
            flag = False
            # 已经经过 i 次冒泡，array[length-i]及之后的数据都是升上去的，已经有序
            for j in range(length-i):
                if array[j] > array[j+1]:
                    array[j], array[j+1] = array[j+1], array[j]
                    flag = True
            if not flag:
                return array

-----------------------------------------------------------------

``插入排序（Insertion Sort）``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

插入排序，顾明思议，就是通过找到对应位置插入的方式进行排序

.. image:: ../_static/images/insertion_sort.jpg

.. tip::

    想象桌子上顺序排列着，数字朝下的扑克，用右手依次拿起扑克放入左手，左手中的牌都是有序的；如果左手中无牌，直接放进左手；
    如果左手中已经有牌，从 ``小拇指向大拇指`` 方向上的左手牌依次与右手牌比大小，如果右手牌较小，左手牌往小拇指
    方向移动一个位置，给右手牌腾地儿，至于右手牌能不能插入这个位置，还有继续往大拇指方向进行
    比较，直到右手牌比左手牌大，此时左手当前牌的位置 ``+1`` 就是右手牌要插入的位置

.. note::

    - 是 ``稳定的算法``，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变
    - 是 ``原地算法``，无需额外的空间，空间复杂度为：O(1)

    插入排序包含两种操作：``比较`` 和 ``移动``:

    - 最坏情况时间复杂度：O(n^2)，数组是逆序的，每个原来都需要比较 ``i`` 次，移动 ``i`` 次（``i`` 为当前元素下标），
      所以 O(n) = 2*(1) + 2*（2)+ ... + 2*(n-1)，故 O(n) = n^2
    - 最好情况时间复杂度：O(n)，数组为有序，只需与 ``左边有序部分最后一个元素`` 做一次比较即可
    - 平均时间复杂度：O(n^2)，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n2)

.. code:: python

    def insertion_sort(array):
        length = len(array)
        # 只有一个数，无需排序
        if length <= 1:
            return array
        for i in range(1, length):
            # 右手起牌
            key = array[i]
            # 小拇指位置
            j = i - 1
            while (j >=0 and array[j] > key):
                # 后移一位，给右手牌腾地儿
                array[j+1] = array[j]
                # 下一个要参与比较的左手牌
                j -= 1
            array[j+1] = key
        return array

------------------------------------------------------------

**选择排序（Selection Sort）**
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾

.. image:: ../_static/images/selection_sort.jpg

.. note::

    - 不是 ``稳定的算法``，比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，
    与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了
    - 是 ``原地算法``，无需额外的空间，空间复杂度为：O(1)

    总的比较次数 N = (n-1)+(n-2)+...+1 = n*(n-1)/2。交换次数 O(n)，最好情况是，已经有序，交换 0 次；最坏情况是，逆序，交换 n-1 次

    - 最坏情况时间复杂度：O(n^2)，
    - 最好情况时间复杂度：O(n^2)
    - 平均时间复杂度：O(n^2)

.. code:: python

    def selection_sort(array):
        length = len(array)
        if length <= 1:
            return array

        for i in range(length):
            min_idx = i
            for j in range(i+1, length):
                if array[min_idx] > array[j]:
                    min_idx = j
            array[i], array[min_idx] = array[min_idx], array[i]
        return array