======================
排序算法比较
======================

- **原地排序（Sorted in place）算法**：特指空间复杂度是 O(1) 的排序算法
- **稳定性**：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变

**基于比较的算法**
-------------------------------

``插入排序``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

插入排序，顾明思议，就是通过找到对应位置插入的方式进行排序

.. image:: ../_static/images/insertion_sort.jpg

.. tip::

    想象桌子上顺序排列着，数字朝下的扑克，用右手依次拿起扑克放入左手，左手中的牌都是有序的；如果左手中无牌，直接放进左手；
    如果左手中已经有牌，从 ``小拇指向大拇指`` 方向上的左手牌依次与右手牌比大小，如果右手牌较小，左手牌往小拇指
    方向移动一个位置，给右手牌腾地儿，至于右手牌能不能插入这个位置，还有继续往大拇指方向进行
    比较，直到右手牌比左手牌大，此时左手当前牌的位置 ``+1`` 就是右手牌要插入的位置

.. note::

    - 是 ``稳定的算法``，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变
    - 是 ``原地算法``，无需额外的空间，时间复杂度为：O(1)

    插入排序包含两种操作：``比较`` 和 ``移动``:

    - 最坏情况时间复杂度：O(n^2)，数组是逆序的，每个原来都需要比较 ``i`` 次，移动 ``i`` 次（``i`` 为当前元素下标），
      所以 O(n) = 2*(1) + 2*（2)+ ... + 2*(n-1)，故 O(n) = n^2
    - 最好情况时间复杂度：O(n)，数组为有序，只需与 ``左边有序部分最后一个元素`` 做一次比较即可

--------------------------------------------------------

.. code:: python

    def insertion_sort(array):
        length = len(array)
        # 只有一个数，无需排序
        if length <= 1:
            return
        for i in range(1, length):
            # 右手起牌
            key = array[i]
            # 小拇指位置
            j = i - 1
            while (j >=0 and array[j] > key):
                # 后移一位，给右手牌腾地儿
                array[j+1] = array[j]
                # 下一个要参与比较的左手牌
                j -= 1
            array[j+1] = key
        return array

---------------------------------------------------------


``归并排序``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

